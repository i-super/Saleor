from decimal import Decimal

import stripe

from . import errors
from ... import TransactionKind
from ....payment.models import Payment
from ...utils import create_transaction
from .forms import StripePaymentModalForm
from .utils import (
    get_amount_for_stripe, get_amount_from_stripe, get_currency_for_stripe,
    get_currency_from_stripe, get_payment_billing_fullname,
    shipping_address_to_stripe_dict)


def get_client_token(**_):
    """Not implemented for stripe gateway currently. The client token can be
    generated by Stripe's checkout.js or stripe.js automatically.
    """
    return


def authorize(payment, payment_token, **connection_params):
    client, error = _get_client(**connection_params), ''

    # Get amount from payment
    amount = payment.total

    try:
        # Authorize without capture
        response = _create_stripe_charge(
            client=client, payment=payment, amount=amount,
            payment_token=payment_token, should_capture=False)
    except stripe.error.StripeError as exc:
        response = _get_error_response_from_exc(exc)
        error = exc.user_message

    # Create transaction
    txn = _create_transaction(
        payment=payment,
        amount=amount,
        kind=TransactionKind.AUTH,
        response=response)

    return txn, error


def capture(payment, amount, **connection_params):
    client, error = _get_client(**connection_params), ''

    # Get amount from argument or payment, and convert to stripe's amount
    amount = amount or payment.total
    stripe_amount = get_amount_for_stripe(amount, payment.currency)

    capture_txn = payment.transactions.filter(
        kind=TransactionKind.AUTH, is_success=True).first()

    if capture_txn is not None:
        try:
            # Retrieve stripe charge and capture specific amount
            stripe_charge = client.Charge.retrieve(capture_txn.token)
            response = stripe_charge.capture(amount=stripe_amount)
        except stripe.error.StripeError as exc:
            response = _get_error_response_from_exc(exc)
            error = exc.user_message
    else:
        error = errors.ORDER_NOT_AUTHORIZED
        response = dict()

    # Create transaction
    txn = _create_transaction(
        payment=payment,
        amount=amount,
        kind=TransactionKind.CAPTURE,
        response=response)

    return txn, error


def charge(payment, payment_token, amount, **connection_params):
    client, error = _get_client(**connection_params), ''

    # Get amount from argument or payment
    amount = amount or payment.total

    try:
        # Charge without pre-authorize
        response = _create_stripe_charge(
            client=client, payment=payment, amount=amount,
            payment_token=payment_token, should_capture=True)
    except stripe.error.StripeError as exc:
        response = _get_error_response_from_exc(exc)
        error = exc.user_message

    # Create transaction
    txn = _create_transaction(
        payment=payment,
        amount=amount,
        kind=TransactionKind.CHARGE,
        response=response)

    return txn, error


def refund(payment, amount, **connection_params):
    client, error = _get_client(**connection_params), ''

    # Get amount from argument or payment, and convert to stripe's amount
    amount = amount or payment.total
    stripe_amount = get_amount_for_stripe(amount, payment.currency)

    capture_txn = payment.transactions.filter(
        kind__in=[TransactionKind.CAPTURE, TransactionKind.CHARGE],
        is_success=True).first()

    if capture_txn is not None:
        try:
            # Retrieve stripe charge and refund specific amount
            stripe_charge = client.Charge.retrieve(capture_txn.token)
            response = client.Refund.create(
                charge=stripe_charge.id, amount=stripe_amount)
        except stripe.error.StripeError as exc:
            response = _get_error_response_from_exc(exc)
            error = exc.user_message
    else:
        error = errors.ORDER_NOT_CHARGED
        response = dict()

    # Create transaction
    txn = _create_transaction(
        payment=payment,
        amount=amount,
        kind=TransactionKind.REFUND,
        response=response)

    return txn, error


def void(payment, **connection_params):
    client, error = _get_client(**connection_params), ''

    capture_txn = payment.transactions.filter(
        kind=TransactionKind.AUTH, is_success=True).first()

    if capture_txn is not None:
        try:
            # Retrieve stripe charge and refund all
            stripe_charge = client.Charge.retrieve(capture_txn.token)
            response = client.Refund.create(charge=stripe_charge.id)
        except stripe.error.StripeError as exc:
            response = _get_error_response_from_exc(exc)
            error = exc.user_message
    else:
        error = errors.ORDER_NOT_AUTHORIZED
        response = dict()

    # Create transaction
    txn = _create_transaction(
        payment=payment,
        amount=payment.total,
        kind=TransactionKind.VOID,
        response=response)

    return txn, error


def get_form_class():
    return StripePaymentModalForm


def _get_client(**connection_params):
    stripe.api_key = connection_params.get('secret_key')
    return stripe


def _get_stripe_charge_payload(
        payment: Payment, amount: Decimal, payment_token: str,
        should_capture: bool):
    shipping_address = payment.order.shipping_address

    # Get currency
    currency = get_currency_for_stripe(payment.currency)

    # Get appropriate amount for stripe
    stripe_amount = get_amount_for_stripe(amount, currency)

    # Get billing name from payment
    name = get_payment_billing_fullname(payment)

    # Construct the charge payload from the data
    charge_payload = {
        'capture': should_capture,
        'amount': stripe_amount,
        'currency': currency,
        'source': payment_token,
        'description': name}

    if shipping_address:
        # Update shipping address to prevent fraud in Stripe
        charge_payload['shipping'] = {
            'name': name,
            'address': shipping_address_to_stripe_dict(shipping_address)}

    return charge_payload


def _create_stripe_charge(
        client, payment, amount: Decimal, payment_token: str,
        should_capture: bool):
    """Create a charge with specific amount, ignoring payment's total."""
    charge_payload = _get_stripe_charge_payload(
        payment, amount, payment_token, should_capture)
    return client.Charge.create(**charge_payload)


def _create_transaction(payment, amount, kind, response):
    # Get currency from response or payment
    currency = get_currency_from_stripe(
        response.get('currency', payment.currency))

    # Get amount from response or payment
    if 'amount' in response:
        stripe_amount = response.get('amount')
        if 'amount_refunded' in response:
            # This happens for partial catpure which will refund the left
            # Then the actual amount should minus refunded amount
            stripe_amount -= response.get('amount_refunded')
        amount = get_amount_from_stripe(stripe_amount, currency)

    # Get token, which is an empty string for error responses
    token = response.get('id', '')

    # Check if the response's status is flagged as succeeded
    is_success = (response.get('status') == 'succeeded')

    # Create transaction
    txn = create_transaction(
        payment=payment,
        token=token,
        kind=kind,
        is_success=is_success,
        amount=amount,
        currency=currency,
        gateway_response=response)

    return txn


def _get_error_response_from_exc(exc):
    response = exc.json_body

    # Some errors from stripe don't json_body as None
    # such as stripe.error.InvalidRequestError
    if response is None:
        response = dict()

    return response
